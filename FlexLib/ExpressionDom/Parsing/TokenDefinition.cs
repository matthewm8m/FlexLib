using System;
using System.Collections.Generic;

namespace FlexLib.ExpressionDom.Parsing
{
    /// <summary>
    /// Represents a definition to create tokens from source code based on a pattern, optional parser, and other parsing parameters.
    /// </summary>
    public class TokenDefinition
    {
        /// <summary>
        /// The user-friendly name of the token definition. Does not need to be specified.
        /// </summary>
        public string Name;
        /// <summary>
        /// The Regular Expression pattern to use for searching in the source.
        /// </summary>
        public string Pattern;
        /// <summary>
        /// Determines if the parser ignores the token or emits it. Set to <c>true</c> to stop the token from being emitted; otherwise, leave set to <c>false</c>.
        /// </summary>
        public bool Ignore;

        /// <summary>
        /// Parses the snippet of source code in order to generate a sequence of tokens to replace it. Subclasses should override this method to yield sequences of tokens or typed tokens.
        /// </summary>
        /// <param name="source">The entire source.</param>
        /// <param name="snippet">The snippet of source that matches the token definition.</param>
        /// <param name="location">The location index of the snippet within the entire source.</param>
        /// <returns>An <see cref="IEnumerable{Token}"/> of tokens generated by the definition.</returns>
        public virtual IEnumerable<Token> Tokenize(string source, string snippet, int location)
        {
            // When using the untyped token definition, there is no token data.
            yield return new Token(source, snippet, location, this);
        }
    }

    /// <summary>
    /// Represents a definition to create tokens of a particular type from source code based on a pattern, optional parser, and other parsing parameters.
    /// </summary>
    /// <typeparam name="T">The type of data to store in generated tokens.</typeparam>
    public class TokenDefinition<T> : TokenDefinition
    {
        /// <summary>
        /// The parsing function to turn the source string into another value and pass it to the created token.
        /// </summary>
        public TokenParser<T> Parser;

        /// <summary>
        /// Parses the snippet of source code in order to generate a sequence of typed tokens to replace it. Subclasses should override this method to yield sequences of tokens or typed tokens.
        /// </summary>
        /// <param name="source">The entire source.</param>
        /// <param name="snippet">The snippet of source that matches the token definition.</param>
        /// <param name="location">The location index of the snippet within the entire source.</param>
        /// <returns>An <see cref="IEnumerable{Token}"/> of tokens generated by the definition.</returns>
        public override IEnumerable<Token> Tokenize(string source, string snippet, int location)
        {
            if (Parser == null)
                yield return new Token(source, snippet, location, this, default(T));
            else
            {
                if (Parser(snippet, out T value))
                    yield return new Token(source, snippet, location, this, value);
                else
                    throw new FormatException();
            }
        }
    }
}